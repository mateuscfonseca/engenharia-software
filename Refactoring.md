Esse √© o primeiro artigo de uma s√©rie. Estou escrevendo essa s√©rie com o intu√≠to de me ajudar a absorver melhor o conte√∫do do livro [Refactoring - 1¬™](https://www.amazon.com.br/Refactoring-Improving-Design-Existing-Code/dp/0134757599).Entendo que ao tentar comunicar o meu entendimento para outras pessoas, sou capaz de refletir de maneira mais rica o conte√∫do do livro e meu entendimento dele. Dito isso, ser√° um prazer imenso ler coment√°rios e sugest√µes de quem ler esse artigo. 


**Considera√ß√µes importantes**

Eu sou adepto do SOLID, por isso voc√™ vai ver eu argumentando que respeitar seus princ√≠pios √© sempre benefico. Isso n√£o quer dizer que acho que devemos seguir esses princ√≠pios de forma autom√°tica, sem a devida reflex√£o dos seus beneficios e maleficios (geralmente aumentar o n√∫mero de abstra√ß√µes,aumentando a complexidade do c√≥digo).

Os exemplos s√£o feitos para ajudar a entender melhor o conceito. Por isso devem ser simples. Isso pode fazer com que pare√ßa desnecess√°rio algumas refatora√ß√µes, como se elas apenas aumentassem a complexidade do c√≥digo. Mas imagine que estamos em um contexto de um sistema que est√° em constante evolu√ß√£o, como  novas funcionalidades e regras de neg√≥cio. 

Outra coisa importante notar √© que algumas t√©cnicas de refatora√ß√£o parecem n√£o levar em considera√ß√£o a performance, especialmente se o c√≥digo for chamado muitas vezes em um loop.E de certa forma √© isso mesmo. Mas isso n√£o √© desconsiderar a perfomance, √© apenas entender que s√£o momentos diferentes do est√°gio de mantuten√ß√£o do c√≥digo.

Um c√≥digo bem estruturado vai ser sempre mais f√°cil de tornar performatico do que um codigo altamente acoplado (faz com que mudan√ßas em uma funcionalidade acabem afetando outras), dificil de entender (aumentando a chance de adi√ß√£o de c√≥digo adicionar bugs). Al√©m disso, tem a quest√£o que nosso instito sobre a performance de uma aplica√ß√£o pode estar completamente errado, apesar de fazer sentido l√≥gico. 

Por isso √© sempre preciso MEDIR a performance para saber o que de fato √© um gargalo ou n√£o. Ent√£o, durante a refatora√ß√£o, n√£o vamos nos preocupar com a performance e tudo bem. Quando formos trabalhar a performance, ai sim podemos abrir m√£o de um alto n√≠vel legibilidade e maior segra√ß√£o de interfaces.

**Todas essas considera√ß√µes s√£o feitas pelo Martin no livro. (menos a parte do SOLID)**

# Chapter 1. Rafactoring, a First Example

O Martin tem uma maneira de escrever seus livros, come√ßando sempre por um exemplo pr√°tico. Nesse exemplo ele j√° mobiliza os diversos conceitos que ele vai posteriormente detalhar.

Antes de come√ßar, ele estressa bastante o ponto de que √© preciso ter testes unit√°rios para poder realizar o refactor com seguran√ßa
	- primeiro testes
	- depois /refactor

Outro ponto importante √©: executar o refactor em pequenos passos, tornando mais f√°cil corrigir se algo der errado. 

> "Any fool can write code that a computer can understand. Good programmers write code that humans can understand."

Abaixo listo as t√©cnicas comentadas nesse capitulo, com exemplos diferentes, que fiz para poder absorver melhor o conte√∫do. Para criar a implementa√ß√£o em Python dos novos exemplos, usei a ajuda do Gepeto (me tornei um programador muito pregui√ßoso, quero s√≥ pensar, deixo a escrita pra LLM üòÇ). Tirando isso, o restante foi escrito por mim. 

## Extract Method

A t√©cnica de refatora√ß√£o Extract Method √© usada quando voc√™ tem um trecho de c√≥digo que pode ser extra√≠do para um novo m√©todo, dando-lhe um nome descritivo e reduzindo a complexidade do m√©todo original. Isso melhora a legibilidade e facilita a manuten√ß√£o do c√≥digo.

### Exemplo
```py
class Order:
    def __init__(self, items):
        self.items = items

    def print_order(self):
        print("Order Details:")
        total_price = 0
        for item in self.items:
            total_price += item['price']
            print(f"Item: {item['name']}, Price: {item['price']}")

        print(f"Total Price: {total_price}")

```

### Problema
Neste exemplo, o m√©todo print_order faz v√°rias coisas: imprime os detalhes de cada item e calcula o pre√ßo total.

### Aplicando o Move Method

```py
class Order:
    def __init__(self, items):
        self.items = items

    def print_order(self):
        print("Order Details:")
        total_price = self._calculate_total_price()
        self._print_items()
        print(f"Total Price: {total_price}")

    def _calculate_total_price(self):
        total_price = 0
        for item in self.items:
            total_price += item['price']
        return total_price

    def _print_items(self):
        for item in self.items:
            print(f"Item: {item['name']}, Price: {item['price']}")

```

*Agora, o m√©todo print_order √© mais simples e leg√≠vel. Ele delega as responsabilidades de calcular o pre√ßo total e imprimir os itens para m√©todos espec√≠ficos (_calculate_total_price e _print_items). Isso segue o princ√≠pio de responsabilidade √∫nica, facilitando a manuten√ß√£o e poss√≠veis futuras altera√ß√µes.*

### Benef√≠cios da Refatora√ß√£o

- A legibilida melhorada: Cada parte do c√°lculo agora tem um nome descritivo, tornando o c√≥digo mais f√°cil de entender.
- Reusabilidade: Se precisarmos do pre√ßo base ou do desconto em outro lugar, podemos simplesmente chamar o m√©todo correspondente.
- Facilidade de Manuten√ß√£o: Se a l√≥gica de c√°lculo mudar (por exemplo, a regra de desconto), s√≥ precisamos modificar o m√©todo espec√≠fico.
- Testabilidade: Cada m√©todo pode ser testado independentemente, facilitando a cria√ß√£o de testes unit√°rios.

## Move Method
A t√©cnica de refatora√ß√£o Move Method √© usada quando voc√™ percebe que um m√©todo em uma classe est√° mais relacionado ou tem maior depend√™ncia de outra classe. A ideia √© mover o m√©todo para a classe onde ele faz mais sentido, melhorando o encapsulamento e a coes√£o.

### Exemplo 

Considere um sistema que gerencia contas banc√°rias e transa√ß√µes. Temos as classes BankAccount e Transaction, onde o m√©todo de c√°lculo de taxas de transa√ß√£o est√° atualmente na classe BankAccount. No entanto, faz mais sentido que essa l√≥gica resida na classe Transaction.

```py
class BankAccount:
    def __init__(self, account_number, balance=0):
        self.account_number = account_number
        self.balance = balance
        self.transactions = []

    def add_transaction(self, transaction):
        self.transactions.append(transaction)

    def calculate_fees(self):
        total_fees = 0
        for transaction in self.transactions:
            if transaction.type == 'withdrawal' and transaction.amount > 100:
                total_fees += transaction.amount * 0.02
            elif transaction.type == 'deposit' and transaction.amount > 1000:
                total_fees += transaction.amount * 0.01
        return total_fees
      

class Transaction:
    def __init__(self, type, amount):
        self.type = type
        self.amount = amount

```

*Repare como no m√©todo que calcula o total de taxas. Ele basicamente usa informa√ß√µes que n√£o pertencem a classe BankAccount.Isso √© um forte sinal de que o m√©todo deveria estar na classe Transaction.*

#### Problema

Aqui, o m√©todo calculate_fees na classe BankAccount depende fortemente dos detalhes de cada transa√ß√£o, como o tipo e o valor. Como essa l√≥gica √© mais relacionada √† transa√ß√£o em si, podemos mov√™-la para a classe Transaction.

#### Aplicando Move Method

Primeiro, movemos a l√≥gica de c√°lculo de taxas para a classe Transaction. Vamos criar um novo m√©todo calculate_fee na classe Transaction.

```python
class BankAccount:
    def __init__(self, account_number, balance=0):
        self.account_number = account_number
        self.balance = balance
        self.transactions = []

    def add_transaction(self, transaction):
        self.transactions.append(transaction)

    def calculate_fees(self):
        total_fees = 0
        for transaction in self.transactions:
            total_fees += transaction.calculate_fee()
        return total_fees
        

class Transaction:
    def __init__(self, type, amount):
        self.type = type
        self.amount = amount

    def calculate_fee(self):
        if self.type == 'withdrawal' and self.amount > 100:
            return self.amount * 0.02
        elif self.type == 'deposit' and self.amount > 1000:
            return self.amount * 0.01
        return 0
```

*Repare que o m√©todo que calcula as taxas n√£o recebe nenhum par√¢metro. Isso √© um sinal de que ele n√£o precisa estar na classe BankAccount, e sim na classe Transaction. N√£o que isso seja uma regra, n√£o tem para metros, move a classe, mas √© um bom indicativo. Em orienta√ß√£o a objetos, um dos objetivos √© que a l√≥gica de um m√©todo dependa de dados que s√£o da sua classe. Por isso a import√¢ncia do conceito de encapsulamento.*

### Benef√≠cios da Refatora√ß√£o

- Legibilidade melhorada: a melhor segmenta√ß√£o do c√≥digo torna a carga cognitiva mais leve, tornando o c√≥digo mais f√°cil de entender.
- Encapsulamento Melhorado: A l√≥gica espec√≠fica de cada transa√ß√£o est√° agora encapsulada dentro da classe Transaction, que √© **respons√°vel pelos detalhes** das transa√ß√µes.
- Maior Coes√£o: A classe BankAccount √© agora mais coesa, focando em gerenciar a conta e delegando a l√≥gica de cada transa√ß√£o para a classe apropriada.
- Facilidade de Manuten√ß√£o: Se as regras de c√°lculo de taxas mudarem, isso pode ser tratado diretamente na classe Transaction, sem afetar a l√≥gica geral da classe BankAccount.


## Replace Type Code with State/Strategy

Essa t√©cnica √© usada quando voc√™ tem um c√≥digo que utiliza tipos ou valores espec√≠ficos para determinar o comportamento (como os tipos de transa√ß√£o no exemplo) e deseja substituir isso por uma estrutura mais orientada a objetos, utilizando padr√µes como [State](https://refactoring.guru/design-patterns/state) ou [Strategy](https://refactoring.guru/design-patterns/strategy).

### Exemplo

No exemplo atual, a classe Transaction usa uma string ('withdrawal' ou 'deposit') para determinar o tipo de transa√ß√£o e, com isso, calcula a taxa correspondente:

```py
class Transaction:
    def __init__(self, type, amount):
        self.type = type
        self.amount = amount

    def calculate_fee(self):
        if self.type == 'withdrawal' and self.amount > 100:
            return self.amount * 0.02
        elif self.type == 'deposit' and self.amount > 1000:
            return self.amount * 0.01
        return 0

```

*Repare como a forma de calcular muda a depender do tipo da transa√ß√£o. Isso √© um sinal de que podemos aplicar o padr√£o [Strategy](https://refactoring.guru/design-patterns/strategy), que vai tornar o c√≥digo mais orientado a objetos e extens√≠vel, respeitando o pr√≠ncipio de Open/Closed, uma vez que adicionar mais formas de calcular taxas n√£o afetar√° o c√≥digo de Transaction.*

### Problema

Usar strings para representar tipos de transa√ß√µes pode tornar o c√≥digo menos robusto e mais dif√≠cil de manter. Al√©m disso, se o c√°lculo da taxa de transa√ß√£o se tornar mais complexo, essa abordagem pode levar a um c√≥digo com muitos condicionais. A t√©cnica Replace Type Code with State/Strategy pode ser aplicada aqui para melhorar a organiza√ß√£o do c√≥digo.

### Aplicando Replace Type Code with State/Strategy

Vamos substituir o uso de strings para representar tipos de transa√ß√£o por uma hierarquia de classes, onde cada classe representa um tipo espec√≠fico de transa√ß√£o e encapsula o comportamento correspondente.

#### Passo 1: Criar a Hierarquia de Classes

Primeiro, criamos uma classe base TransactionType e subclasses espec√≠ficas para cada tipo de transa√ß√£o (Withdrawal e Deposit), que implementam o m√©todo calculate_fee de maneira diferente.

```py
from abc import ABC, abstractmethod

class TransactionType(ABC):
    @abstractmethod
    def calculate_fee(self, amount):
        pass

class Withdrawal(TransactionType):
    def calculate_fee(self, amount):
        if amount > 100:
            return amount * 0.02
        return 0

class Deposit(TransactionType):
    def calculate_fee(self, amount):
        if amount > 1000:
            return amount * 0.01
        return 0
```

#### Passo 2: Refatorar a Classe Transaction
Agora, modificamos a classe Transaction para utilizar uma inst√¢ncia de TransactionType em vez de uma string:

```py
class Transaction:
    def __init__(self, transaction_type, amount):
        self.transaction_type = transaction_type
        self.amount = amount

    def calculate_fee(self):
        return self.transaction_type.calculate_fee(self.amount)
```

Agora, ao inv√©s de verificar o tipo de transa√ß√£o usando strings, Transaction delega o c√°lculo da taxa √† inst√¢ncia da estrat√©gia apropriada.  

### Benef√≠cios da Refatora√ß√£o

- Elimina√ß√£o de Condicionais: O c√≥digo que antes usava condicionais para determinar o comportamento agora usa polimorfismo, onde cada classe de transa√ß√£o encapsula seu pr√≥prio comportamento.
- Maior Flexibilidade: Novos tipos de transa√ß√£o podem ser adicionados simplesmente criando novas subclasses de TransactionType, sem precisar modificar a classe Transaction ou adicionar mais condicionais.
- C√≥digo Mais Limpo e Manuten√≠vel: O uso de objetos em vez de c√≥digos de tipo torna o c√≥digo mais organizado e facilita futuras expans√µes ou modifica√ß√µes.

## Replace Conditional with Polymorphism
Replace Conditional with Polymorphism √© uma t√©cnica de refatora√ß√£o que substitui condicionais complexas (como if-else ou switch-case) por polimorfismo. Isso √© feito criando uma hierarquia de classes onde cada classe concreta implementa um comportamento espec√≠fico. Essa abordagem melhora a legibilidade, facilita a manuten√ß√£o e reduz a complexidade do c√≥digo.

Como estamos fazendo baseado em uma estrutura de classes, podemos usar o conceito de polimorfismo, que √© uma t√©cnica de refatora√ß√£o que substitui condicionais complexas (como if-else ou switch-case) por polimorfismo. 

Isso √© poss√≠vel pois a classe que chama o m√©todo depende apenas da classe abstrata TransactionType, e n√£o da sua implementa√ß√£o concreta. 

Isso faz com que n√£o seja necessario condicionais, uma vez que ao receber um objeto TransactionType, o m√©todo calculate_fee pode ser chamado de forma independente da classe concreta que implementa o m√©todo. 

Ao instanciar uma Transcation, informamos qual a classe TransactionType que vai ser usada para calcular a taxa, e o m√©todo Transaction chama o m√©todo calculate_fee da inst√¢ncia da classe TransactionType.

No exemplo anterior, tinhamos:

- Condicionais Existentes: 

   O c√≥digo original usava condicionais para verificar o tipo de transa√ß√£o ('withdrawal' ou 'deposit') e, com base nisso, aplicava uma l√≥gica diferente no c√°lculo da taxa.

- Refatora√ß√£o com Polimorfismo:

   Em vez de manter esses condicionais, criamos uma hierarquia de classes (TransactionType, Withdrawal, e Deposit), onde cada classe implementa o m√©todo calculate_fee de forma distinta, de acordo com o tipo de transa√ß√£o.

   Esse √© o princ√≠pio central do Replace Conditional with Polymorphism: o comportamento vari√°vel √© tratado por meio de classes distintas e polimorfismo, em vez de condicionais.

- Respeita o princ√≠pio de Open/Closed:
    Adicionar novos comportamentos √© uma questao de implmentar novas subclasses de TransactionType, e n√£o de modificar a classe Transaction. Isso √© um sinal de que o c√≥digo deve ser aberto para extens√£o, mas fechado para modifica√ß√£o.
Entendi. Vou criar um exemplo semelhante para a t√©cnica "Replace Temp With Query" que acabamos de discutir. Aqui est√°:

## Replace Temp With Query

A t√©cnica de refatora√ß√£o "Replace Temp With Query" √© utilizada quando voc√™ tem uma vari√°vel tempor√°ria que armazena o resultado de uma express√£o. A ideia √© substituir essa vari√°vel por uma chamada de m√©todo, melhorando a legibilidade e a manutenibilidade do c√≥digo.

### Exemplo

Considere um sistema de gerenciamento de pedidos em uma loja online. Temos uma classe `Order` que calcula o pre√ßo total de um pedido, incluindo descontos.

```python
class Order:
    def __init__(self, quantity, item_price):
        self.quantity = quantity
        self.item_price = item_price

    def calculate_total(self):
        base_price = self.quantity * self.item_price
        quantity_discount = 0
        if self.quantity > 100:
            quantity_discount = base_price * 0.1
        shipping = base_price * 0.1
        return base_price - quantity_discount + shipping
```

**Obs:** 
Repare como temos v√°rias vari√°veis tempor√°rias (`base_price`, `quantity_discount`, `shipping`) que armazenam resultados intermedi√°rios. Isso pode tornar o c√≥digo mais dif√≠cil de entender e manter, especialmente se esses c√°lculos forem necess√°rios em outros lugares.

#### Problema

O m√©todo `calculate_total` usa v√°rias vari√°veis tempor√°rias para c√°lculos intermedi√°rios. Isso pode dificultar a compreens√£o do c√≥digo e levar a duplica√ß√µes se esses c√°lculos forem necess√°rios em outros lugares.

#### Aplicando Replace Temp With Query

Vamos refatorar o c√≥digo substituindo cada vari√°vel tempor√°ria por uma chamada de m√©todo:

```python
class Order:
    def __init__(self, quantity, item_price):
        self.quantity = quantity
        self.item_price = item_price

    def calculate_total(self):
        return self.base_price() - self.quantity_discount() + self.shipping()

    def base_price(self):
        return self.quantity * self.item_price

    def quantity_discount(self):
        return self.base_price() * 0.1 if self.quantity > 100 else 0

    def shipping(self):
        return self.base_price() * 0.1
```

**Obs:**
Repare que agora n√£o temos mais vari√°veis tempor√°rias. Cada c√°lculo intermedi√°rio foi transformado em um m√©todo. Isso torna o c√≥digo mais leg√≠vel e cada parte do c√°lculo pode ser facilmente reutilizada ou testada individualmente.

### Benef√≠cios da Refatora√ß√£o

- **Legibilidade Melhorada**: Cada parte do c√°lculo agora tem um nome descritivo, tornando o c√≥digo mais f√°cil de entender.
- **Reusabilidade**: Se precisarmos do pre√ßo base ou do desconto em outro lugar, podemos simplesmente chamar o m√©todo correspondente.
- **Facilidade de Manuten√ß√£o**: Se a l√≥gica de c√°lculo mudar (por exemplo, a regra de desconto), s√≥ precisamos modificar o m√©todo espec√≠fico.
- **Testabilidade**: Cada m√©todo pode ser testado independentemente, facilitando a cria√ß√£o de testes unit√°rios.

### Considera√ß√µes

- **Performance**: Em alguns casos, substituir vari√°veis por chamadas de m√©todo pode ter um pequeno impacto na performance, especialmente se o m√©todo for chamado muitas vezes em um loop.
- **Complexidade**: Para c√°lculos muito simples, criar um m√©todo separado pode parecer excessivo. Use seu julgamento para decidir quando a refatora√ß√£o vale a pena.

Ao aplicar "Replace Temp With Query", voc√™ est√° essencialmente transformando dados (vari√°veis) em comportamento (m√©todos), o que geralmente leva a um design mais orientado a objetos e mais flex√≠vel.

# Chapter 2. Principles in Refactoring

> Refatorar √© mudar a estrutura interna de um programa, mas n√£o mudar seu comportamento. (Substantivo)

> Alterar um software aplicando uma s√©rie de refatora√ß√µes sem alterar o seu comportamento observavel.

> O objetivo da refatora√ß√£o √© tornar o c√≥digo mais leg√≠vel, mais f√°cil de manter e mais flex√≠vel. √â bastante diferente de otimizar o software, pois nesse caso o desempenho √© mais importante que a legibilidade e facilidade de manuten√ß√£o.

## Os dois chap√©is
Ken Beck, um dos maiores desenvolvedores de software da hist√≥ria, fala sobre a ideia de dois chap√©is. Tem o chap√©u de adi√ß√£o de funcionalidade e o chap√©u de refatora√ß√£o. Quando voc√™ est√° adicionando funcionalidade, seu objetivo √© adicionar um novo comportamente ao sistema. Quando voc√™ est√° refatorando, seu objetivo √© tornar o c√≥digo mais leg√≠vel, mais f√°cil de manter e mais flex√≠vel, sem adicionar novos comportamentos.

## Por que refatorar?

> Sem refatora√ß√£o, o design do sistema vai degradar ao longo do tempo, tornando-o mais dif√≠cil de manter e menos flex√≠vel. A atua√ß√£o de diferentes pessoas e equipes tamb√©m pode fazer o sistema perder sua arquitetura. Isso vai tornar entender o design do sistema mais dificil. 

> Quanto mais dificil de pereber um design, mais dif√≠cil √© manter e refatorar.

> Isso faz com que para mudar um peda√ßo de c√≥digo acabe sendo necess√°rio escrever mais linhas. O que em si contribui para piorar o problema.

> Uma das causas de se tornar mais d√≠ficil √© por que um sistema mal estruturado tende a ter muita repeti√ß√£o de c√≥digo. Entao, para mudar o c√≥digo √© necess√°rio verificar se existe alguma repeti√ß√£o, e vc acaba tendo que fazer a mesma altera√ß√£o em v√°rios lugares.

> Quanto mais c√≥digo, mais dif√≠cil √© modificar corretamente. Ou seja, sem a introdu√ß√£o de bugs.

> A remo√ß√£o de duplica√ß√£o vc garante que o c√≥digo diga tudo que tem que dizer e apenas uma vez, o que √© a essencia de um bom design.

## Refatora√ß√£o torna o c√≥digo mais f√°cil de entender

Para sermos capazes de trabalhar de forma efetiva em um sistema, √© necess√°rio entender seu c√≥digo e design. A refatora√ß√£o, ao garantir a preserva√ß√£o da estrutura do c√≥digo e sua legibilidade, a refatora√ß√£o garante que a proxima pessoa a trabalhar no seu c√≥digo, tenha a possibilidade de entender rapidamente e ser capaz de alterar com maior seguran√ßa, visto que um dos resultaedos da refatora√ß√£o √© deixar o c√≥digo aberto para extensao e fechado para modifica√ß√£o.

Refatorar tamb√©m √© um alinhado ao processo de entendimento de um sistema. Isso pq ao modificar o codigo, sem modificar seu comportamento, vc acaba expressando o mesmo comportamento mas agora dentro de um arcabou√ßo de ideias que vc esta propondo ao refatorar, te tornando mais dono do c√≥digo e entendedor da sua motiva√ß√£o e forma correta de funcionamento.

## Refatorar te ajuda a achar bugs

Ao facilitar o entendimento de um sistema, refatorar tamb√©m ajuda a achar bugs. Quando vc refatora, vc acaba entendendo o c√≥digo e sua estrutura, e ao encontrar um bug, vc acaba entendendo o que est√° errado e como corrigir. 

## Refatorar ajuda a programar mais r√°pido

Uma boa estrutura de c√≥digo torna ele mais facil de extender, isso pq a extensibilidade  √© uma das caracter√≠sitcas que a refatora√ß√£o vai trazer. Como a uplica√ß√£o √© minima, siguinifica que vai ter que alterar em menos lugares, diminuindo o espa√ßo para erros. Tamb√©m torna testar mais f√°cil, uma vez que outra consequencia da refatora√ß√£o √© a melhor seguimenta√ß√£o do c√≥digo, melhor organiza√ß√£o das abstra√ß√µes do neg√≥cio, e isso tora o teste unitario mais rapido de fazer. 

